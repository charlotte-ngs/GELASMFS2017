<!DOCTYPE html>
<html >

<head>

  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <title>Angewandte Statistische Methoden in den Nutztierwissenschaften</title>
  <meta name="description" content="Unterlagen zur Vorlesung Angewandte Statistische Methoden in den Nutztierwissenschaften.">
  <meta name="generator" content="bookdown 0.3.9 and GitBook 2.6.7">

  <meta property="og:title" content="Angewandte Statistische Methoden in den Nutztierwissenschaften" />
  <meta property="og:type" content="book" />
  
  
  <meta property="og:description" content="Unterlagen zur Vorlesung Angewandte Statistische Methoden in den Nutztierwissenschaften." />
  

  <meta name="twitter:card" content="summary" />
  <meta name="twitter:title" content="Angewandte Statistische Methoden in den Nutztierwissenschaften" />
  
  <meta name="twitter:description" content="Unterlagen zur Vorlesung Angewandte Statistische Methoden in den Nutztierwissenschaften." />
  

<meta name="author" content="Peter von Rohr">


<meta name="date" content="2017-04-20">

  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black">
  
  
<link rel="prev" href="linreg.html">
<link rel="next" href="chpt-lasso.html">
<script src="libs/jquery-2.2.3/jquery.min.js"></script>
<link href="libs/gitbook-2.6.7/css/style.css" rel="stylesheet" />
<link href="libs/gitbook-2.6.7/css/plugin-bookdown.css" rel="stylesheet" />
<link href="libs/gitbook-2.6.7/css/plugin-highlight.css" rel="stylesheet" />
<link href="libs/gitbook-2.6.7/css/plugin-search.css" rel="stylesheet" />
<link href="libs/gitbook-2.6.7/css/plugin-fontsettings.css" rel="stylesheet" />









<style type="text/css">
div.sourceCode { overflow-x: auto; }
table.sourceCode, tr.sourceCode, td.lineNumbers, td.sourceCode {
  margin: 0; padding: 0; vertical-align: baseline; border: none; }
table.sourceCode { width: 100%; line-height: 100%; }
td.lineNumbers { text-align: right; padding-right: 4px; padding-left: 4px; color: #aaaaaa; border-right: 1px solid #aaaaaa; }
td.sourceCode { padding-left: 5px; }
code > span.kw { color: #007020; font-weight: bold; } /* Keyword */
code > span.dt { color: #902000; } /* DataType */
code > span.dv { color: #40a070; } /* DecVal */
code > span.bn { color: #40a070; } /* BaseN */
code > span.fl { color: #40a070; } /* Float */
code > span.ch { color: #4070a0; } /* Char */
code > span.st { color: #4070a0; } /* String */
code > span.co { color: #60a0b0; font-style: italic; } /* Comment */
code > span.ot { color: #007020; } /* Other */
code > span.al { color: #ff0000; font-weight: bold; } /* Alert */
code > span.fu { color: #06287e; } /* Function */
code > span.er { color: #ff0000; font-weight: bold; } /* Error */
code > span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
code > span.cn { color: #880000; } /* Constant */
code > span.sc { color: #4070a0; } /* SpecialChar */
code > span.vs { color: #4070a0; } /* VerbatimString */
code > span.ss { color: #bb6688; } /* SpecialString */
code > span.im { } /* Import */
code > span.va { color: #19177c; } /* Variable */
code > span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code > span.op { color: #666666; } /* Operator */
code > span.bu { } /* BuiltIn */
code > span.ex { } /* Extension */
code > span.pp { color: #bc7a00; } /* Preprocessor */
code > span.at { color: #7d9029; } /* Attribute */
code > span.do { color: #ba2121; font-style: italic; } /* Documentation */
code > span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code > span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code > span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
</style>

<link rel="stylesheet" href="style.css" type="text/css" />
</head>

<body>



  <div class="book without-animation with-summary font-size-2 font-family-1" data-basepath=".">

    <div class="book-summary">
      <nav role="navigation">

<ul class="summary">
<li><a href="./">Angewandte Statistische Methoden</a></li>

<li class="divider"></li>
<li class="chapter" data-level="" data-path="index.html"><a href="index.html"><i class="fa fa-check"></i>Vorwort</a><ul>
<li class="chapter" data-level="" data-path="index.html"><a href="index.html#motivation"><i class="fa fa-check"></i>Motivation</a></li>
<li class="chapter" data-level="" data-path="index.html"><a href="index.html#einordnung"><i class="fa fa-check"></i>Einordnung</a></li>
<li class="chapter" data-level="" data-path="index.html"><a href="index.html#lernziele"><i class="fa fa-check"></i>Lernziele</a></li>
</ul></li>
<li class="chapter" data-level="1" data-path="intro.html"><a href="intro.html"><i class="fa fa-check"></i><b>1</b> Einführung</a><ul>
<li class="chapter" data-level="1.1" data-path="intro.html"><a href="intro.html#problem"><i class="fa fa-check"></i><b>1.1</b> Beschreibung des Problems</a></li>
<li class="chapter" data-level="1.2" data-path="intro.html"><a href="intro.html#background"><i class="fa fa-check"></i><b>1.2</b> Rückblick</a><ul>
<li class="chapter" data-level="1.2.1" data-path="intro.html"><a href="intro.html#paradigmenwechsel"><i class="fa fa-check"></i><b>1.2.1</b> Paradigmenwechsel</a></li>
<li class="chapter" data-level="1.2.2" data-path="intro.html"><a href="intro.html#vor-der-genomischen-selektion"><i class="fa fa-check"></i><b>1.2.2</b> Vor der genomischen Selektion</a></li>
<li class="chapter" data-level="1.2.3" data-path="intro.html"><a href="intro.html#modellierung-vor-der-genomischen-selektion"><i class="fa fa-check"></i><b>1.2.3</b> Modellierung vor der genomischen Selektion</a></li>
</ul></li>
<li class="chapter" data-level="1.3" data-path="intro.html"><a href="intro.html#gensel"><i class="fa fa-check"></i><b>1.3</b> Genomische Selektion</a><ul>
<li class="chapter" data-level="1.3.1" data-path="intro.html"><a href="intro.html#modellierung"><i class="fa fa-check"></i><b>1.3.1</b> Modellierung</a></li>
<li class="chapter" data-level="1.3.2" data-path="intro.html"><a href="intro.html#zwei-schritt-verfahren"><i class="fa fa-check"></i><b>1.3.2</b> Zwei-Schritt-Verfahren</a></li>
<li class="chapter" data-level="1.3.3" data-path="intro.html"><a href="intro.html#eigenschaften-von-blup-zuchtwerten"><i class="fa fa-check"></i><b>1.3.3</b> Eigenschaften von BLUP-Zuchtwerten</a></li>
<li class="chapter" data-level="1.3.4" data-path="intro.html"><a href="intro.html#einsatz-von-blup-zuchtwerten-in-der-genomischen-selektion"><i class="fa fa-check"></i><b>1.3.4</b> Einsatz von BLUP-Zuchtwerten in der genomischen Selektion</a></li>
</ul></li>
<li class="chapter" data-level="1.4" data-path="intro.html"><a href="intro.html#zusammenfassung"><i class="fa fa-check"></i><b>1.4</b> Zusammenfassung</a></li>
<li class="chapter" data-level="1.5" data-path="intro.html"><a href="intro.html#ausblick"><i class="fa fa-check"></i><b>1.5</b> Ausblick</a></li>
</ul></li>
<li class="chapter" data-level="2" data-path="linreg.html"><a href="linreg.html"><i class="fa fa-check"></i><b>2</b> Multiple Lineare Regression</a><ul>
<li class="chapter" data-level="2.1" data-path="linreg.html"><a href="linreg.html#beispiele-fur-lineare-regressionen"><i class="fa fa-check"></i><b>2.1</b> Beispiele für Lineare Regressionen</a><ul>
<li class="chapter" data-level="2.1.1" data-path="linreg.html"><a href="linreg.html#regression-mit-achsenabschnitt"><i class="fa fa-check"></i><b>2.1.1</b> Regression mit Achsenabschnitt</a></li>
<li class="chapter" data-level="2.1.2" data-path="linreg.html"><a href="linreg.html#regression-durch-den-ursprung"><i class="fa fa-check"></i><b>2.1.2</b> Regression durch den Ursprung</a></li>
<li class="chapter" data-level="2.1.3" data-path="linreg.html"><a href="linreg.html#regression-mit-transformierten-variablen"><i class="fa fa-check"></i><b>2.1.3</b> Regression mit transformierten Variablen</a></li>
<li class="chapter" data-level="2.1.4" data-path="linreg.html"><a href="linreg.html#anwendungen-in-den-nutztierwissenschaften"><i class="fa fa-check"></i><b>2.1.4</b> Anwendungen in den Nutztierwissenschaften</a></li>
<li class="chapter" data-level="2.1.5" data-path="linreg.html"><a href="linreg.html#ziele-der-linearen-regression"><i class="fa fa-check"></i><b>2.1.5</b> Ziele der linearen Regression</a></li>
</ul></li>
<li class="chapter" data-level="2.2" data-path="linreg.html"><a href="linreg.html#methode-der-kleinsten-quadrate-least-squares"><i class="fa fa-check"></i><b>2.2</b> Methode der kleinsten Quadrate (Least Squares)</a><ul>
<li class="chapter" data-level="2.2.1" data-path="linreg.html"><a href="linreg.html#annahmen-hinter-dem-linearen-modell"><i class="fa fa-check"></i><b>2.2.1</b> Annahmen hinter dem linearen Modell</a></li>
<li class="chapter" data-level="2.2.2" data-path="linreg.html"><a href="linreg.html#kein-ersatz-der-multiplen-regression-durch-mehrere-einfache-regressionen"><i class="fa fa-check"></i><b>2.2.2</b> Kein Ersatz der multiplen Regression durch mehrere einfache Regressionen</a></li>
</ul></li>
<li class="chapter" data-level="2.3" data-path="linreg.html"><a href="linreg.html#eigenschaften-der-schatzungen"><i class="fa fa-check"></i><b>2.3</b> Eigenschaften der Schätzungen</a><ul>
<li class="chapter" data-level="2.3.1" data-path="linreg.html"><a href="linreg.html#momente-der-least-squares-schatzungen"><i class="fa fa-check"></i><b>2.3.1</b> Momente der Least-Squares Schätzungen</a></li>
<li class="chapter" data-level="2.3.2" data-path="linreg.html"><a href="linreg.html#verteilung-der-least-squares-schatzer-unter-normalverteilten-fehlern"><i class="fa fa-check"></i><b>2.3.2</b> Verteilung der Least-Squares-Schätzer unter normalverteilten Fehlern</a></li>
</ul></li>
<li class="chapter" data-level="2.4" data-path="linreg.html"><a href="linreg.html#tests-und-vertrauensintervalle"><i class="fa fa-check"></i><b>2.4</b> Tests und Vertrauensintervalle</a><ul>
<li class="chapter" data-level="2.4.1" data-path="linreg.html"><a href="linreg.html#einzeltests"><i class="fa fa-check"></i><b>2.4.1</b> Einzeltests</a></li>
<li class="chapter" data-level="2.4.2" data-path="linreg.html"><a href="linreg.html#globaler-test"><i class="fa fa-check"></i><b>2.4.2</b> Globaler Test</a></li>
<li class="chapter" data-level="2.4.3" data-path="linreg.html"><a href="linreg.html#vertrauensintervalle"><i class="fa fa-check"></i><b>2.4.3</b> Vertrauensintervalle</a></li>
</ul></li>
<li class="chapter" data-level="2.5" data-path="linreg.html"><a href="linreg.html#output-von-r"><i class="fa fa-check"></i><b>2.5</b> Output von R</a></li>
<li class="chapter" data-level="2.6" data-path="linreg.html"><a href="linreg.html#analyse-der-residuen-und-uberprufung-der-modellannahmen"><i class="fa fa-check"></i><b>2.6</b> Analyse der Residuen und Überprüfung der Modellannahmen</a><ul>
<li class="chapter" data-level="2.6.1" data-path="linreg.html"><a href="linreg.html#tukey-anscombe-plot"><i class="fa fa-check"></i><b>2.6.1</b> Tukey-Anscombe Plot</a></li>
<li class="chapter" data-level="2.6.2" data-path="linreg.html"><a href="linreg.html#der-qq-plot"><i class="fa fa-check"></i><b>2.6.2</b> Der QQ-Plot</a></li>
</ul></li>
<li class="chapter" data-level="2.7" data-path="linreg.html"><a href="linreg.html#selektion-eines-modells"><i class="fa fa-check"></i><b>2.7</b> Selektion eines Modells</a><ul>
<li class="chapter" data-level="2.7.1" data-path="linreg.html"><a href="linreg.html#mallows-c_p-statistik"><i class="fa fa-check"></i><b>2.7.1</b> Mallows <span class="math inline">\(C_p\)</span>-Statistik</a></li>
<li class="chapter" data-level="2.7.2" data-path="linreg.html"><a href="linreg.html#modellwahl-mit-dem-c_p-kriterium"><i class="fa fa-check"></i><b>2.7.2</b> Modellwahl mit dem <span class="math inline">\(C_p\)</span>-Kriterium</a></li>
<li class="chapter" data-level="2.7.3" data-path="linreg.html"><a href="linreg.html#bemerkungen"><i class="fa fa-check"></i><b>2.7.3</b> Bemerkungen</a></li>
</ul></li>
</ul></li>
<li class="chapter" data-level="3" data-path="gblup.html"><a href="gblup.html"><i class="fa fa-check"></i><b>3</b> Genomic Best Linear Unbiased Prediction (GBLUP)</a><ul>
<li class="chapter" data-level="3.1" data-path="gblup.html"><a href="gblup.html#dna-markers"><i class="fa fa-check"></i><b>3.1</b> DNA Markers</a></li>
<li class="chapter" data-level="3.2" data-path="gblup.html"><a href="gblup.html#markerinformationen-in-blup-verfahren"><i class="fa fa-check"></i><b>3.2</b> Markerinformationen in BLUP-Verfahren</a><ul>
<li class="chapter" data-level="3.2.1" data-path="gblup.html"><a href="gblup.html#ridge-regression-rr-blup"><i class="fa fa-check"></i><b>3.2.1</b> Ridge Regression (RR) BLUP</a></li>
<li class="chapter" data-level="3.2.2" data-path="gblup.html"><a href="gblup.html#genomic-blup-gblup"><i class="fa fa-check"></i><b>3.2.2</b> Genomic BLUP (GBLUP)</a></li>
</ul></li>
<li class="chapter" data-level="3.3" data-path="gblup.html"><a href="gblup.html#genomische-verwandtschaftsmatrix-grm"><i class="fa fa-check"></i><b>3.3</b> Genomische Verwandtschaftsmatrix (GRM)</a><ul>
<li class="chapter" data-level="3.3.1" data-path="gblup.html"><a href="gblup.html#herleitung-der-grm"><i class="fa fa-check"></i><b>3.3.1</b> Herleitung der GRM</a></li>
<li class="chapter" data-level="3.3.2" data-path="gblup.html"><a href="gblup.html#genetische-effekte-als-summe-der-snp-effekte"><i class="fa fa-check"></i><b>3.3.2</b> Genetische Effekte als Summe der SNP-Effekte</a></li>
<li class="chapter" data-level="3.3.3" data-path="gblup.html"><a href="gblup.html#genetische-effekte-als-abweichungen"><i class="fa fa-check"></i><b>3.3.3</b> Genetische Effekte als Abweichungen</a></li>
<li class="chapter" data-level="3.3.4" data-path="gblup.html"><a href="gblup.html#alternative-codierung"><i class="fa fa-check"></i><b>3.3.4</b> Alternative Codierung</a></li>
<li class="chapter" data-level="3.3.5" data-path="gblup.html"><a href="gblup.html#varianz-der-genetischen-effekte"><i class="fa fa-check"></i><b>3.3.5</b> Varianz der genetischen Effekte</a></li>
<li class="chapter" data-level="3.3.6" data-path="gblup.html"><a href="gblup.html#r-code-zur-berechnung-der-grm"><i class="fa fa-check"></i><b>3.3.6</b> R-Code zur Berechnung der GRM</a></li>
</ul></li>
<li class="chapter" data-level="3.4" data-path="gblup.html"><a href="gblup.html#wie-gblup-funktioniert"><i class="fa fa-check"></i><b>3.4</b> Wie GBLUP funktioniert</a></li>
</ul></li>
<li class="chapter" data-level="4" data-path="chpt-lasso.html"><a href="chpt-lasso.html"><i class="fa fa-check"></i><b>4</b> Least Absolute Shrinkage And Selection Operator (LASSO)</a><ul>
<li class="chapter" data-level="4.1" data-path="chpt-lasso.html"><a href="chpt-lasso.html#stochastische-restkomponente"><i class="fa fa-check"></i><b>4.1</b> Stochastische Restkomponente</a></li>
<li class="chapter" data-level="4.2" data-path="chpt-lasso.html"><a href="chpt-lasso.html#parameterschatzung"><i class="fa fa-check"></i><b>4.2</b> Parameterschätzung</a></li>
<li class="chapter" data-level="4.3" data-path="chpt-lasso.html"><a href="chpt-lasso.html#alternativen-zu-least-squares"><i class="fa fa-check"></i><b>4.3</b> Alternativen zu Least Squares</a></li>
<li class="chapter" data-level="4.4" data-path="chpt-lasso.html"><a href="chpt-lasso.html#sec-lasso"><i class="fa fa-check"></i><b>4.4</b> Lasso</a><ul>
<li class="chapter" data-level="4.4.1" data-path="chpt-lasso.html"><a href="chpt-lasso.html#regularisierung-bei-lasso"><i class="fa fa-check"></i><b>4.4.1</b> Regularisierung bei LASSO</a></li>
<li class="chapter" data-level="4.4.2" data-path="chpt-lasso.html"><a href="chpt-lasso.html#subset-selection-bei-lasso"><i class="fa fa-check"></i><b>4.4.2</b> Subset Selection bei LASSO</a></li>
</ul></li>
<li class="chapter" data-level="4.5" data-path="chpt-lasso.html"><a href="chpt-lasso.html#bestimmung-von-lambda"><i class="fa fa-check"></i><b>4.5</b> Bestimmung von <span class="math inline">\(\lambda\)</span></a></li>
<li class="chapter" data-level="4.6" data-path="chpt-lasso.html"><a href="chpt-lasso.html#analyse-mit-lasso-in-r"><i class="fa fa-check"></i><b>4.6</b> Analyse mit LASSO in R</a></li>
</ul></li>
<li class="chapter" data-level="5" data-path="bayes.html"><a href="bayes.html"><i class="fa fa-check"></i><b>5</b> Bayes’sche Ansätze</a><ul>
<li class="chapter" data-level="5.1" data-path="bayes.html"><a href="bayes.html#einfuhrung"><i class="fa fa-check"></i><b>5.1</b> Einführung</a></li>
<li class="chapter" data-level="5.2" data-path="bayes.html"><a href="bayes.html#das-lineare-modell"><i class="fa fa-check"></i><b>5.2</b> Das Lineare Modell</a><ul>
<li class="chapter" data-level="5.2.1" data-path="bayes.html"><a href="bayes.html#bekannte-und-unbekannte"><i class="fa fa-check"></i><b>5.2.1</b> Bekannte und Unbekannte</a></li>
<li class="chapter" data-level="5.2.2" data-path="bayes.html"><a href="bayes.html#vorgehen-bei-parameterschatzung"><i class="fa fa-check"></i><b>5.2.2</b> Vorgehen bei Parameterschätzung</a></li>
</ul></li>
<li class="chapter" data-level="5.3" data-path="bayes.html"><a href="bayes.html#gibbs-sampler"><i class="fa fa-check"></i><b>5.3</b> Gibbs Sampler</a><ul>
<li class="chapter" data-level="5.3.1" data-path="bayes.html"><a href="bayes.html#a-priori-verteilungen"><i class="fa fa-check"></i><b>5.3.1</b> A priori Verteilungen</a></li>
<li class="chapter" data-level="5.3.2" data-path="bayes.html"><a href="bayes.html#likelihood"><i class="fa fa-check"></i><b>5.3.2</b> Likelihood</a></li>
<li class="chapter" data-level="5.3.3" data-path="bayes.html"><a href="bayes.html#vollbedingte-verteilungen"><i class="fa fa-check"></i><b>5.3.3</b> Vollbedingte Verteilungen</a></li>
<li class="chapter" data-level="5.3.4" data-path="bayes.html"><a href="bayes.html#umsetzung-des-gibbs-samplers"><i class="fa fa-check"></i><b>5.3.4</b> Umsetzung des Gibbs Samplers</a></li>
</ul></li>
</ul></li>
<li class="chapter" data-level="" data-path="abkurzungen.html"><a href="abkurzungen.html"><i class="fa fa-check"></i>Abkürzungen</a></li>
<li class="chapter" data-level="" data-path="references.html"><a href="references.html"><i class="fa fa-check"></i>References</a></li>
<li class="divider"></li>
<li><a href="https://github.com/rstudio/bookdown" target="blank">Published with bookdown</a></li>

</ul>

      </nav>
    </div>

    <div class="book-body">
      <div class="body-inner">
        <div class="book-header" role="navigation">
          <h1>
            <i class="fa fa-circle-o-notch fa-spin"></i><a href="./">Angewandte Statistische Methoden in den Nutztierwissenschaften</a>
          </h1>
        </div>

        <div class="page-wrapper" tabindex="-1" role="main">
          <div class="page-inner">

            <section class="normal" id="section-">
<div id="gblup" class="section level1">
<h1><span class="header-section-number">Kapitel 3</span> Genomic Best Linear Unbiased Prediction (GBLUP)</h1>
<p>Die Methode GBLUP verwendet genomische Verwandtschaftsbeziehungen zur Schätzung des genetischen Potentials von Individuen. Die genomische Verwandtschaft wird aufgrund von DNA-Informationen geschätzt. Die genomische Verwandtschaftsmatrix <span class="math inline">\(G\)</span> definiert die Kovarianz zwischen Individuen aufgrund von Ähnlichkeiten auf dem Niveau der genomischen Information. Diese Definition der Kovarianz steht im Gegensatz zur Kovarianz aufgrund der erwarteten Ähnlichkeit aufgrund von Pedigrees in der traditionellen Verwandtschaftsmatrix <span class="math inline">\(A\)</span>.</p>
<div id="dna-markers" class="section level2">
<h2><span class="header-section-number">3.1</span> DNA Markers</h2>
<p>Die Verfügbarkeit von Markerkarten in genügender Dichte verteilt über das ganze Genom, ermöglicht die Schätzung des genetischen Potentials von Individuen basierend auf der beobachteten Markerinformation. Das aktuell am weitesten verbreitete Markermodell wird als <code>Single Nucleotide Polymorphism</code> (SNP) bezeichnet. Bei den SNPs handelt es sich um Positionen im Genom, an welchen Unterschiede zwischen Individuen einer Population bei einer einzelnen DNA-Base auftreten. Nehmen wir an, dass Genorte (QTL), welche wichtig sind für die Expression von interessanten phänotypischen Eigenschaften, sich in der Nähe von beobachteten SNPs befinden, können wir aufgrund von Kopplungsungleichgewichten zwischen SNPs und QTL eine statistische Beziehung zwischen phänotypischen Werten und SNP-Genotypen modellieren.</p>
<p>Für die Schätzung der SNP-Effekte auf phänotypische Ausprägungen stehen verschiedene statistische Verfahren zur Verfügung. Als einfachste Methode können wir die Regression auf einzelne SNP-Marker bezeichnen. Das Problem der Single-Marker Regression liegt in der im Vergleich zur Anzahl der Beobachtungen sehr grossen Anzahl an SNP-Markern. Eine Lösung dieses Problems besteht darin, dass die SNP-Effekte im linearen Modell als zufällige Effekte aufgefasst werden. Dadurch wird das einfache lineare Regressionsmodell in ein lineares gemischtes Modell verwandelt. Aus der traditionellen Zuchtwertschätzung (<span class="citation">(Hofer <a href="#ref-Hofer1990">1990</a>)</span> und <span class="citation">(von Rohr <a href="#ref-vonRohr2016">2016</a>)</span>) kennen wir die Mischmodellgleichungen, welche uns Schätzwerte für fixe und zufällige Effekte mit BLUE- und BLUP-Eigenschaften liefern. Bei diesem Verfahren werden aber allen SNPs der gleiche Varianzanteil zugesprochen. Die totale genetische Varianz wird somit auf alle SNPs gleichmässig aufgeteilt. Bayes’sche Methoden, wie sie in Kapitel <a href="bayes.html#bayes">5</a> beschrieben sind, erlauben es verschiedenen genomischen Regionen verschiedene Varianzanteile zuzuordnen.</p>
</div>
<div id="markerinformationen-in-blup-verfahren" class="section level2">
<h2><span class="header-section-number">3.2</span> Markerinformationen in BLUP-Verfahren</h2>
<p>Parameterschätzverfahren, welche zu Schätzungen für fixe Effekte mit <code>Best Linear Unbiased Estimation</code> (BLUE)-Eigenschaften und zu Vorhersagen von zufälligen Effekten mit <code>Best Linear Unbiased Prediction</code> (BLUP)-Eigenschaften führen werden hier kurz als <strong>BLUP-Verfahren</strong> bezeichnet. Die traditionelle Zuchtwertschätzung basiert auf Pedigreeinformationen zur Schätzung der Covarianz zwischen zufälligen Effekten (Zuchtwerten) von verwandten Tieren. Die Covarianz kann aber auch aufgrund von Markerinformation geschätzt werden. Die aufgrund von SNPs erstellte Matrix wird als <code>Genomic Relationship Matrix</code> (GRM) bezeichnet.</p>
<p>Wir besprechen hier zwei verschiedene Ansätze</p>
<ol style="list-style-type: decimal">
<li><code>Ridge Regression</code> (RR)-BLUP</li>
<li><code>Genomic BLUP</code> (GBLUP)</li>
</ol>
<div id="ridge-regression-rr-blup" class="section level3">
<h3><span class="header-section-number">3.2.1</span> Ridge Regression (RR) BLUP</h3>
<p>Diese Methode wurde von <span class="citation">(Meuwissen, Hayes, and Goddard <a href="#ref-MHG2001">2001</a>)</span> und <span class="citation">(Habier, Fernando, and Dekkers <a href="#ref-HFD2007">2007</a>)</span> untersucht. Dabei haben die Autoren das folgende Modell angenommen.</p>
<span class="math display">\[\begin{equation}
y = 1_n\mu + Wq + e
\label{eq:RRBlupModel}
\end{equation}\]</span>

<p>Die Genotypen an jedem SNP-Locus in Matrix <span class="math inline">\(W\)</span> werden mit <span class="math inline">\(0\)</span>, <span class="math inline">\(1\)</span> und <span class="math inline">\(2\)</span> codiert. Diese Codes repräsentieren die Anzahl an SNP-Allelen mit positiver Wirkung. Die SNP-Effekte werden als zufällig betrachtet. Das Modell in () ist also ein gemischtes lineares Modell. Die unbekannten Parameter werden mit Hilfe von Mischmodellgleichungen geschätzt. Der geschätzte genomische Zuchtwert entspricht der Summe der SNP-Effekte über alle SNP-Loci. Die durch die SNP-Effekte erklärte Varianz ist gleich <span class="math inline">\(WW^T\sigma_q^2\)</span>. Die Varianz der Resteffekte wird als <span class="math inline">\(I\sigma_e^2\)</span> angenommen. Somit entspricht die Covarianz zwischen Beobachtungen <span class="math inline">\(WW^T\sigma_q^2 + I\sigma_e^2\)</span>. In RR-BLUP wird die Varianz an allen SNPs als konstant angenommen.</p>
</div>
<div id="genomic-blup-gblup" class="section level3">
<h3><span class="header-section-number">3.2.2</span> Genomic BLUP (GBLUP)</h3>
<p>Die zweite Methode, welche genomische Information berücksichtigt verwendet die genomische Verwandtschaftsmatrix <span class="math inline">\(G\)</span> anstelle der additiv genetischen Verwandtschaftsmatrix <span class="math inline">\(A\)</span> in einem gemischten linearen Modell. Dieser Ansatz wird als <strong>gBLUP</strong> bezeichnet. Das Modell zur Umsetzung von gBLUP lautet</p>
<span class="math display">\[\begin{equation}
y = Xb + Zg + e
\label{eq:GblupModel}
\end{equation}\]</span>

<p>Der Vektor <span class="math inline">\(g\)</span> enthält zufällige genetische Effekte für alle Tiere, welche typisiert sind. Diese Tiere können Beobachtungen aufweisen oder nicht. Die Tiere mit Beobachtungen und Typisierungsergebnisse werden allgemein als Trainings- oder Referenzpopulation bezeichnet. Die Tiere ohne phänotypische Beobachtung mit Typisierungsergebnissen bilden das Testset, für welche die genomischen Zuchtwerte geschätzt werden sollen. Die Varianz <span class="math inline">\(var(g) = G * \sigma_g^2\)</span> wobei <span class="math inline">\(G\)</span> der genomischen Verwandtschaftsmatrix entspricht. Die zufälligen Resteffekte werden als unabhängig angenommen mit der Covarianzmatrix <span class="math inline">\(var(e) = I*\sigma_e^2\)</span>.</p>
<p>GBLUP hat drei wichtige Vorteile im Vergleich zu RR-BLUP.</p>
<ol style="list-style-type: decimal">
<li>Die Dimension der genetischen Effekte in GBLUP beträgt <span class="math inline">\(n\times n\)</span>, wobei <span class="math inline">\(n\)</span> die Anzahl Tiere sind. In RR-BLUP beträgt diese Dimension <span class="math inline">\(m\times m\)</span>, wobei <span class="math inline">\(m\)</span> der Anzahl an SNP-Markern entspricht. Somit ist GBLUP effizienter im Hinblick auf Rechenresourcen.</li>
<li>Die Genauigkeiten der genomischen Zuchtwerte können bei GBLUP analog zu den Genauigkeiten der Zuchtwerte im BLUP-Tiermodell berechnet werden.</li>
<li>GBLUP kann mit Pedigree-basierten Informationen zu den sogenannten <strong>single step</strong> Verfahren kombiniert werden <span class="citation">(Misztal, Legarra, and Aguilar <a href="#ref-MLA2009">2009</a>)</span>.</li>
</ol>
</div>
</div>
<div id="genomische-verwandtschaftsmatrix-grm" class="section level2">
<h2><span class="header-section-number">3.3</span> Genomische Verwandtschaftsmatrix (GRM)</h2>
<p>Die Covarianz zwischen den gentischen Effekten <span class="math inline">\(g\)</span> im Modell () wird über die genomische Verwandtschaftsmatrix <span class="math inline">\(G\)</span> ausgedrückt. Analog zum BLUP-Tiermodell, soll die Covarianz der genetischen Effekte als Produkt der genomischen Verwandtschaftsmatrix <span class="math inline">\(G\)</span> mal die Varianzkomponente <span class="math inline">\(\sigma_g^2\)</span> dargestellt werden.</p>
<div id="herleitung-der-grm" class="section level3">
<h3><span class="header-section-number">3.3.1</span> Herleitung der GRM</h3>
<p>Als erstes stellt sich die Frage, wie wir die genetischen Effekte <span class="math inline">\(g\)</span> überhaupt definieren sollen. Auf dieser Definition von <span class="math inline">\(g\)</span> aufbauend können wir uns anschliessend überlegen, wie die Matrix <span class="math inline">\(G\)</span> aufgestellt werden kann. Die folgenden Eigenschaften für die genetischen Effekte <span class="math inline">\(g\)</span> und für die GRM <span class="math inline">\(G\)</span> sollen gelten.</p>
<ol style="list-style-type: decimal">
<li>Die genetischen Effekte <span class="math inline">\(g\)</span> sollen der Summe aller SNP-Effekte <span class="math inline">\(q\)</span> entsprechen.</li>
<li>Die genetischen Effekte <span class="math inline">\(g\)</span> sollen nicht als Absolute Werte sondern analog zu den Zuchtwerten aus dem BLUP-Tiermodell als Abweichungen von einer festgelegten Basis definiert sein, das heisst der Erwartungswert <span class="math inline">\(E\left[g\right] = 0\)</span>.</li>
<li>Wie schon erwähnt soll die Covarianz der genetischen Effekte <span class="math inline">\(g\)</span> dem Produkt aus GRM <span class="math inline">\(G\)</span> und der Varianzkomponente <span class="math inline">\(\sigma_g^2\)</span> entsprechen, d.h. <span class="math inline">\(var(g) = G * \sigma_g^2\)</span>.</li>
<li>Die GRM <span class="math inline">\(G\)</span> soll ähnlich wie die additive Verwandtschaftsmatrix <span class="math inline">\(A\)</span> aussehen, d.h. die Diagnoalelemente sollen um <span class="math inline">\(1\)</span> liegen und auf der Offdiagonalen sollen hohe Werte mit genetisch ähnlichen Tieren assoziiert werden.</li>
</ol>
<p>Als Informationsquellen für die Definition von <span class="math inline">\(g\)</span> und zum Aufstellen der GRM <span class="math inline">\(G\)</span> haben wir die SNP-Markerinformationen zur Verfügung. Das hier vorgestellte Material basiert auf den Arbeiten von <span class="citation">(VanRaden <a href="#ref-VanRaden2008">2008</a>)</span> und von <span class="citation">(Gianola et al. <a href="#ref-GDHMF2009">2009</a>)</span>. In den folgenden Unterabschnitten wollen wir die Konsequenzen der oben aufgelisteten Eigenschaften analysieren und daraus die GRM <span class="math inline">\(G\)</span> aufstellen.</p>
</div>
<div id="genetische-effekte-als-summe-der-snp-effekte" class="section level3">
<h3><span class="header-section-number">3.3.2</span> Genetische Effekte als Summe der SNP-Effekte</h3>
<p>Basierend auf der SNP-Markerinformation können wir Effekte für die einzelnen SNP-Marker schätzen. Wir nehmen hier also an, dass wir den Vektor <span class="math inline">\(q\)</span> kennen. Formell bedeutet die Eigenschaft, dass die genetischen Effekte <span class="math inline">\(g\)</span> als Summe der SNP-Effekte <span class="math inline">\(q\)</span> dargestellte werden können, dass es eine Matrix <span class="math inline">\(U\)</span> gibt, für welche gilt, dass</p>
<span class="math display">\[\begin{equation}
g = U * q
\label{eq:VecGSumOfVecQ}
\end{equation}\]</span>
<p>wobei an dieser Stelle die Matrix <span class="math inline">\(U\)</span> noch unbekannt ist. Wir werden diese anhand der nächsten Eigenschaft bestimmten.</p>
</div>
<div id="genetische-effekte-als-abweichungen" class="section level3">
<h3><span class="header-section-number">3.3.3</span> Genetische Effekte als Abweichungen</h3>
<p>Die genetischen Effekte sollen, analog zu den Zuchtwerten aus dem BLUP-Tiermodell als Abweichungen von einer festgelegten Basis definiert werden. Die Basis stellt den Nullpunkt der genetischen Effekte dar. Somit kommen die einzelnen Genetischen Effekte <span class="math inline">\(g_i\)</span> für Tier <span class="math inline">\(i\)</span> aus einer Verteilung mit Erwartungswert <span class="math inline">\(E\left[g_i\right] = 0\)</span>. Die Frage ist nun, wie muss die Matrix <span class="math inline">\(U\)</span> aussehen, dass unabhängig vom Vektor <span class="math inline">\(q\)</span> der Erwartungswert der Komponenten von <span class="math inline">\(g_i\)</span> gleich null ist.</p>
<p>Betrachten wir die Zufallsvariable <span class="math inline">\(w\)</span> mit den SNP-Genotypencodes in Matrix <span class="math inline">\(W\)</span> im RR-BLUP-Modell () und nehmen wir an, das Hardy-Weinberg-Gleichgewicht gelte für alle SNP-Genorte, dann sind folgende Realisierungswerte für <span class="math inline">\(w\)</span> möglich</p>
<span class="math display">\[\begin{equation}
w = \left\{ \begin{array}{lll}
0  &amp;  \text{mit Wahrscheinlichkeit} &amp; (1-p)^2\\
1  &amp;  \text{mit Wahrscheinlichkeit} &amp; 2p(1-p) \\
2  &amp;  \text{mit Wahrscheinlichkeit} &amp; p^2
\end{array}
\right.
\label{eq:RandVarGenotypesW}
\end{equation}\]</span>
<p>Der Erwartungswert der Zufallsvariablen <span class="math inline">\(w\)</span> entspricht</p>
<span class="math display">\[\begin{equation}
E\left[w\right] = 0*(1-p)^2 + 1 * 2p(1-p) + 2 * p^2 = 2p
\label{eq:ExpectedValueW}
\end{equation}\]</span>
<p>Die Matrix <span class="math inline">\(U\)</span> aus () berechnen wir als Differenz zwischen den Matrizen <span class="math inline">\(W\)</span> und <span class="math inline">\(P\)</span>. Die Matrix <span class="math inline">\(P\)</span> besteht aus Kolonnenvektoren <span class="math inline">\(1_n2p_j\)</span> der Länge <span class="math inline">\(n\)</span> für die entsprechenden SNPs <span class="math inline">\(j = 1,\ldots ,m\)</span>. Für einen bestimmten SNP-Locus <span class="math inline">\(j\)</span> folgen aufgrund der Definition der Matrix <span class="math inline">\(U\)</span> die folgenden Codierungen der SNP-Genotypen. Dabei nehmen wir an, dass das Allel <span class="math inline">\((G_{2})_j\)</span> einerseits mit Frequenz <span class="math inline">\(p_j\)</span> auftritt und andererseits dasjenige Allel mit der positiven Wirkung ist. Die nachfolgende Tabelle gibt eine Übersicht über die genotypischen Werte und der Codierung der Genotypen in der Matrix <span class="math inline">\(U\)</span> für die drei auftretenden Genotypen am SNP-Locus <span class="math inline">\(j\)</span>.</p>


<p>Unter der Annahme des Hardy-Weinberg-Gleichgewichts für die Genotypen am SNP-Locus <span class="math inline">\(j\)</span> können wir den Erwartungswert für den genetischen Effekt <span class="math inline">\(g\)</span> am SNP-Locus <span class="math inline">\(j\)</span> berechnen. Der Erwartungswert wird über alle Komponenten des Vektors <span class="math inline">\(g\)</span> der genetischen Effekte berechnet.</p>
<span class="math display">\[\begin{equation}
\begin{split}
E\left[g\right]_j &amp; = \left[(1-p_j)^2(-2p_j) + 2p_j(1-p_j)(1-2p_j) + p_j^2(2-2p_j)\right]q_j\\
  &amp; = \left[(1 - 2p_j + p_j^2)(-2p_j) + (2p_j - 2p_j^2)(1-2p_j) + p_j^2(2-2p_j)\right]q_j\\
  &amp; = \left[-2p_j + 4p_j^2 - 2p_j^3 + 2p_j - 4p_j^2 - 2p_j^2 + 4p_j^3 + 2p_j^2 - 2p_j^3\right]q_j\\
  &amp; = 0
\end{split}
\label{eq:ExpectedValueGj}
\end{equation}\]</span>
<p>Die gleiche Herleitung lässt sich für jeden SNP Locus <span class="math inline">\(j = 1,\ldots, m\)</span> machen. Somit ist der Erwartungswert über alle genetischen Komponenten <span class="math inline">\(g_i\)</span> gleich null, unabhängig von den SNP-Effekten <span class="math inline">\(q_j\)</span> am Locus <span class="math inline">\(j\)</span>. Somit haben wir die Matrix <span class="math inline">\(U\)</span>, welche aus den SNP-Effekten <span class="math inline">\(q\)</span> in () die genetischen Effekte <span class="math inline">\(g\)</span> in () berechnet, gefunden.</p>
</div>
<div id="alternative-codierung" class="section level3">
<h3><span class="header-section-number">3.3.4</span> Alternative Codierung</h3>
<p>Anstelle der verwendeten Codierungen von <span class="math inline">\(0\)</span>, <span class="math inline">\(1\)</span> und <span class="math inline">\(2\)</span> für die SNP-Genotypen können diese auch mit <span class="math inline">\(-1\)</span>, <span class="math inline">\(0\)</span> und <span class="math inline">\(1\)</span> codiert werden. Diese Codierung wird in <span class="citation">(VanRaden <a href="#ref-VanRaden2008">2008</a>)</span> zum Aufstellen der GRM <span class="math inline">\(G\)</span> verwendet. Auch die Autoren des Papers <span class="citation">(Gianola et al. <a href="#ref-GDHMF2009">2009</a>)</span> verwenden diese alternative Codierung. Am prinzipiellen Vorgehen ändert sich aber dadurch nichts. Nur die verwendeten Werte in den Matrizen sind anders. Die Matrix <span class="math inline">\(W\)</span> unter der alternativen Codierung besteht aus Werten <span class="math inline">\(-1\)</span>, <span class="math inline">\(0\)</span> und <span class="math inline">\(1\)</span>. Die Zufallsvariable <span class="math inline">\(w\)</span>, welche wir in () definiert und zur Bestimmung der Matrix <span class="math inline">\(P\)</span> verwendet hatten, sieht unter der alternativen Codierung wie folgt aus.</p>
<span class="math display">\[\begin{equation}
w = \left\{ \begin{array}{lll}
-1  &amp;  \text{mit Wahrscheinlichkeit} &amp; (1-p)^2\\
0  &amp;  \text{mit Wahrscheinlichkeit} &amp; 2p(1-p) \\
1  &amp;  \text{mit Wahrscheinlichkeit} &amp; p^2
\end{array}
\right.
\label{eq:RandVarGenotypesWalternative}
\end{equation}\]</span>
<p>Der Erwartungswert für <span class="math inline">\(w\)</span> unter der alternativen Codierung ist dann</p>
<span class="math display">\[\begin{equation}
E\left[w\right] = (-1)*(1-p)^2 + 0 * 2p(1-p) + 1 * p^2 = -1 + 2p - p^2 + p^2 = 2p - 1 = 2(p - 0.5)
\label{eq:ExpectedValueWalternative}
\end{equation}\]</span>
<p>Die Kolonne <span class="math inline">\(j\)</span> der Matrix <span class="math inline">\(P\)</span> besteht aus dem Kolonnenvektoren <span class="math inline">\(1_n*2(p_j - 0.5)\)</span>. Die Matrix <span class="math inline">\(U\)</span> (welche der Matrix <span class="math inline">\(Z\)</span> in <span class="citation">(VanRaden <a href="#ref-VanRaden2008">2008</a>)</span> entspricht) kann wird berechnet als</p>
<span class="math display">\[\begin{equation}
U = W - P
\label{eq:MatrixUalternative}
\end{equation}\]</span>
<p>Die Elemente der Matrix <span class="math inline">\(U\)</span> der Genotypen am SNP-Locus <span class="math inline">\(j\)</span> unter der alternativen Codierung lauten</p>

<p>Der Erwartungswert der Komponenten der genetischen Effekte <span class="math inline">\(g\)</span> aufgrund des SNP-Locus <span class="math inline">\(j\)</span> beträgt dann</p>
<span class="math display">\[\begin{equation}
\begin{split}
E\left[g\right]_j &amp; = \left[(1-p_j)^2(-1-2(p_j-0.5)) + 2p_j(1-p_j)(-2(p_j-0.5)) + p_j^2(1-2(p_j-0.5))\right]q_j\\
  &amp; = \left[- 2 \ p_j^{3} + 4 \ p_j^{2} - 2 \ p_j 
            + 4 \ p_j^{3} - 6 \ p_j^{2} + 2 \ p_j 
            - 2 \ p_j^{3} + 2 \  p_j^{2} \right]q_j\\
  &amp; = 0
\end{split}
\label{eq:ExpectedValueGjalternative}
\end{equation}\]</span>
</div>
<div id="varianz-der-genetischen-effekte" class="section level3">
<h3><span class="header-section-number">3.3.5</span> Varianz der genetischen Effekte</h3>
<p>Aufgrund der postulierten Eigenschaften soll die Varianz <span class="math inline">\(var(g)\)</span> der genetischen Effekte berechnet werden als das Produkt der GRM <span class="math inline">\(G\)</span> mal die gemeinsame Varianzkomponente <span class="math inline">\(\sigma_g^2\)</span>. Als Formel geschrieben lautet der Ausdruck für <span class="math inline">\(var(g)\)</span></p>
<span class="math display">\[\begin{equation}
var(g) = G * \sigma_g^2\text{.}
\label{eq:VarGFormula}
\end{equation}\]</span>
<p>Aus der Theorie folgt unter Berücksichtigung von (), dass</p>
<p><span class="math display">\[var(g) = U * var(q) * U^T\]</span> ist. Für die Varianz der SNP-Effekte nehmen wir an, dass <span class="math inline">\(var(q) = I\sigma_q^2\)</span>. Dies bedeutet, dass sich der Ausdruck für die Kovarianz der genetischen Effekte <span class="math inline">\(g\)</span> vereinfacht zu <span class="math inline">\(var(g) = UU^T \sigma_q^2\)</span>.</p>
<p>Im Paper von <span class="citation">(Gianola et al. <a href="#ref-GDHMF2009">2009</a>)</span> wurde <span class="math inline">\(\sigma_g^2\)</span> aus <span class="math inline">\(\sigma_q^2\)</span> hergeleitet. Das Resultat dieser Herleitung lautet</p>
<span class="math display">\[\begin{equation}
\sigma_g^2 = 2 \sum_j^m p_j(1-p_j) \sigma_q^2
\label{eq:GenomicVariance}
\end{equation}\]</span>
<p>Fassen wir alle diese Beziehungen zusammen, können wir die verschiedenen Ausdrücke für die Kovarianz der genetischen Effekte gleichsetzen.</p>
<span class="math display">\[\begin{equation}
var(g) = G * \sigma_g^2 = UU^T \sigma_q^2
\label{eq:GenomicVarianceTwoExpr}
\end{equation}\]</span>
<p>Ersetzen wir <span class="math inline">\(\sigma_g^2\)</span> in () durch den Ausdruck in () so folgt</p>
<span class="math display">\[\begin{equation}
G * 2 \sum_j^m p_j(1-p_j) \sigma_q^2 = UU^T \sigma_q^2
\label{eq:GenomicVarianceInserted}
\end{equation}\]</span>
<p>Aus der Gleichung in () kann die genomische Verwandtschaftsmatrix <span class="math inline">\(G\)</span> berechnet werden als</p>
<span class="math display">\[\begin{equation}
G = \frac{UU^T}{2\sum_j p_j(1-p_j)}
\label{eq:GenomRelMat}
\end{equation}\]</span>
</div>
<div id="r-code-zur-berechnung-der-grm" class="section level3">
<h3><span class="header-section-number">3.3.6</span> R-Code zur Berechnung der GRM</h3>
<p>Im Kapitel 13 von <span class="citation">(Clark and van der Werf <a href="#ref-CV2013">2013</a>)</span> ist ein R-Programm zur Berechnung der genomischen Verwandtschaftsmatrix aufgeführt. Wir wollen dieses Programm analysieren und präsentieren auch eine alternative Art der Berechnung der genomischen Verwandtschaftsmatrix.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="co"># Making the genomic relationship matrix</span>
nmarkers &lt;-<span class="st"> </span><span class="dv">1000</span>
<span class="co"># Reading SNP-Genotype codes (0,1,2) from file</span>
data &lt;-<span class="st"> </span><span class="kw">matrix</span>(<span class="kw">scan</span>(<span class="st">&quot;genotypes.txt&quot;</span>),<span class="dt">ncol =</span> nmarkers,<span class="dt">byrow =</span> <span class="ot">TRUE</span>)
<span class="co"># Initialisation of variables</span>
sumpq =<span class="st"> </span><span class="dv">0</span>
freq =<span class="st"> </span><span class="kw">dim</span>(data)[<span class="dv">1</span>]
P =<span class="st"> </span>freq
lamda =<span class="st"> </span><span class="kw">ncol</span>(data)
<span class="co"># Compute allele frequencies and column vectors of matrix P</span>
for(i in <span class="dv">1</span>:<span class="kw">ncol</span>(data)){
  (freq[i]  &lt;-<span class="st"> </span>((<span class="kw">mean</span>(data[,i])/<span class="dv">2</span>)))
  (P[i] =<span class="st"> </span>(<span class="dv">2</span>*(freq[i]-<span class="fl">0.5</span>)))
  (<span class="dt">sumpq =</span> sumpq+(freq[i]*(<span class="dv">1</span>-freq[i])))
}
<span class="co"># Transform coding from (0,1,2) to (-1,0,1) and subtract P</span>
Z &lt;-<span class="st"> </span>data
for(i in <span class="dv">1</span>:<span class="kw">nrow</span>(data)){
  for(j in <span class="dv">1</span>:<span class="kw">ncol</span>(data)){
    (Z[i,j] &lt;-<span class="st"> </span>((data[i,j]-<span class="dv">1</span>)-(P[j])))
  }
}
<span class="co"># Compute GRM</span>
Zt =<span class="st"> </span><span class="kw">t</span>(Z)
ZtZ =<span class="st"> </span>Z%*%Zt
G =<span class="st"> </span>ZtZ/(<span class="dv">2</span>*sumpq)
G</code></pre></div>
<pre><code>##            [,1]       [,2]       [,3]       [,4]       [,5]
## [1,]  0.8978768 -0.2330233 -0.2286366 -0.2067029 -0.2295139
## [2,] -0.2330233  0.8469907 -0.2014388 -0.2189858 -0.1935427
## [3,] -0.2286366 -0.2014388  0.9171785 -0.2453062 -0.2417968
## [4,] -0.2067029 -0.2189858 -0.2453062  0.9215652 -0.2505703
## [5,] -0.2295139 -0.1935427 -0.2417968 -0.2505703  0.9154238</code></pre>
<p>Das gezeigte Programm zur Berechnung der genomischen Verwandtschaftsmatrix aus <span class="citation">(Clark and van der Werf <a href="#ref-CV2013">2013</a>)</span> kann vereinfacht werden. Insbesondere können die <code>for</code>-loops durch einfachere Funktionen und vektorisierte Berechnungen ersetzt werden. Das folgende Programm berechnet die gleiche genomische Verwandtschafsmatrix.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="co"># Making the genomic relationship matrix</span>
nmarkers &lt;-<span class="st"> </span><span class="dv">1000</span>
<span class="co"># Reading SNP-Genotype codes (0,1,2) from file</span>
data &lt;-<span class="st"> </span><span class="kw">matrix</span>(<span class="kw">scan</span>(<span class="st">&quot;genotypes.txt&quot;</span>),<span class="dt">ncol =</span> nmarkers,<span class="dt">byrow =</span> <span class="ot">TRUE</span>)
<span class="co"># Compute allele frequencies, column vectors of matrix P and sum of frequency products</span>
freq &lt;-<span class="st"> </span><span class="kw">apply</span>(data, <span class="dv">2</span>, mean) /<span class="st"> </span><span class="dv">2</span>
P &lt;-<span class="st"> </span><span class="dv">2</span> *<span class="st"> </span>(freq -<span class="st"> </span><span class="fl">0.5</span>)
sumpq &lt;-<span class="st"> </span><span class="kw">sum</span>(freq*(<span class="dv">1</span>-freq))
<span class="co"># Compute matrix Z by first changing the coding from (0,1,2) </span>
<span class="co"># to (-1,0,1) and then subtracting matrix P</span>
Z &lt;-<span class="st"> </span>data -<span class="st"> </span><span class="dv">1</span> -<span class="st"> </span><span class="kw">matrix</span>(P, <span class="dt">nrow =</span> <span class="kw">nrow</span>(data), <span class="dt">ncol =</span> <span class="kw">ncol</span>(data), <span class="dt">byrow =</span> <span class="ot">TRUE</span>)
<span class="co"># Z%*%Zt is replaced by tcrossprod(Z)</span>
(matGrm &lt;-<span class="st"> </span><span class="kw">tcrossprod</span>(Z)/(<span class="dv">2</span>*sumpq))</code></pre></div>
<pre><code>##            [,1]       [,2]       [,3]       [,4]       [,5]
## [1,]  0.8978768 -0.2330233 -0.2286366 -0.2067029 -0.2295139
## [2,] -0.2330233  0.8469907 -0.2014388 -0.2189858 -0.1935427
## [3,] -0.2286366 -0.2014388  0.9171785 -0.2453062 -0.2417968
## [4,] -0.2067029 -0.2189858 -0.2453062  0.9215652 -0.2505703
## [5,] -0.2295139 -0.1935427 -0.2417968 -0.2505703  0.9154238</code></pre>
<p>Wir können überprüfen, ob die beiden Matrizen identisch sind</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">all.equal</span>(G, matGrm)</code></pre></div>
<pre><code>## [1] TRUE</code></pre>
<p>Das oben gezeigte alternative Programm zur Berechnung der genomischen Verwandtschaftsmatrix kann so verwendet werden. Da R eine funktionale Programmiersprache ist, soll es unser Ziel sein, möglichst viele Aufgaben in Funktionen zu kapseln. Die folgende Funktion <code>computeMatGrm()</code> berechnet aufgrund der Datenmatrix die genomischen Verwandtschaftsmatrix auf.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="co">#&#39; Compute genomic relationship matrix based on data matrix</span>
computeMatGrm &lt;-<span class="st"> </span>function(pmatData) {
  <span class="co"># Allele frequencies, column vector of P and sum of frequency products</span>
  freq &lt;-<span class="st"> </span><span class="kw">apply</span>(pmatData, <span class="dv">2</span>, mean) /<span class="st"> </span><span class="dv">2</span>
  P &lt;-<span class="st"> </span><span class="dv">2</span> *<span class="st"> </span>(freq -<span class="st"> </span><span class="fl">0.5</span>)
  sumpq &lt;-<span class="st"> </span><span class="kw">sum</span>(freq*(<span class="dv">1</span>-freq))
  <span class="co"># Changing the coding from (0,1,2) to (-1,0,1) and subtract matrix P</span>
  Z &lt;-<span class="st"> </span>data -<span class="st"> </span><span class="dv">1</span> -<span class="st"> </span><span class="kw">matrix</span>(P, <span class="dt">nrow =</span> <span class="kw">nrow</span>(pmatData), 
                         <span class="dt">ncol =</span> <span class="kw">ncol</span>(pmatData), 
                         <span class="dt">byrow =</span> <span class="ot">TRUE</span>)
  <span class="co"># Z%*%Zt is replaced by tcrossprod(Z)</span>
  <span class="kw">return</span>(<span class="kw">tcrossprod</span>(Z)/(<span class="dv">2</span>*sumpq))
}

<span class="co"># Computing the genomic relationship matrix using the above defined function</span>
nmarkers &lt;-<span class="st"> </span><span class="dv">1000</span>
<span class="co"># Reading SNP-Genotype codes (0,1,2) from file</span>
data &lt;-<span class="st"> </span><span class="kw">matrix</span>(<span class="kw">scan</span>(<span class="st">&quot;genotypes.txt&quot;</span>),<span class="dt">ncol =</span> nmarkers,<span class="dt">byrow =</span> <span class="ot">TRUE</span>)
<span class="co"># calling the function</span>
(matGrmFunc &lt;-<span class="st"> </span><span class="kw">computeMatGrm</span>(<span class="dt">pmatData =</span> data))</code></pre></div>
<pre><code>##            [,1]       [,2]       [,3]       [,4]       [,5]
## [1,]  0.8978768 -0.2330233 -0.2286366 -0.2067029 -0.2295139
## [2,] -0.2330233  0.8469907 -0.2014388 -0.2189858 -0.1935427
## [3,] -0.2286366 -0.2014388  0.9171785 -0.2453062 -0.2417968
## [4,] -0.2067029 -0.2189858 -0.2453062  0.9215652 -0.2505703
## [5,] -0.2295139 -0.1935427 -0.2417968 -0.2505703  0.9154238</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="co"># checking the result</span>
<span class="kw">all.equal</span>(G, matGrmFunc)</code></pre></div>
<pre><code>## [1] TRUE</code></pre>
</div>
</div>
<div id="wie-gblup-funktioniert" class="section level2">
<h2><span class="header-section-number">3.4</span> Wie GBLUP funktioniert</h2>
<p>Die genomischen Verwandtschaftsmatrix erlaubt es uns die Daten der Tiere mit Beobachtung mit den Tieren ohne Beobachtungen aber mit SNP-Genotypen zu verlinken. Die Inverse <span class="math inline">\(G^{-1}\)</span> der genomischen Verwandtschaftsmatrix wird zur Modellierung der Kovarianzstruktur zwischen den genetischen Effekten und somit zwischen den genomischen Zuchtwerten verwendet. Wie schon beim BLUP-Tiermodell werden auch bei GBLUP die unbekannten Effekte mit Mischmodellgleichungen geschätzt. Für das GBLUP-Modell in () lauten die Mischmodellgleichungen, wie folgt.</p>
<p><span class="math display">\[\left[
\begin{array}{lll}
  X^TX &amp; X^TZ &amp; 0 \\ 
  Z^TX &amp; Z^TZ + G^{11} &amp; G^{12} \\ 
  0 &amp; G^{21} &amp; G^{22} \\ 
  \end{array}\right]
\left[
\begin{array}{l}
  \hat{b} \\ 
  \hat{g}_1 \\ 
  \hat{g}_2 \\ 
  \end{array}\right]
 = \left[
\begin{array}{l}
  X^Ty \\ 
  Z^Ty \\ 
  0 \\ 
  \end{array}\right]
\]</span></p>
<p><span class="math inline">\(G^{11}\)</span> steht für den Teil der Inversen <span class="math inline">\(G^{-1}\)</span>, der zu den Tieren mit phänotypischen Beobachtungen gehört. Analog dazu entspricht <span class="math inline">\(G^{22}\)</span> dem Teil von <span class="math inline">\(G^{-1}\)</span>, der die Tiere ohne Beobachtungen mit nur SNP-Genotypen beinhaltet. Die Teile <span class="math inline">\(G^{12}\)</span> und <span class="math inline">\(G^{21}\)</span> verknüpfen die Tiere mit und ohne Beobachtungen. Bei den oben gezeigten Mischmodellgleichungen wird ein Verhältnis der Varianzkomponenten <span class="math inline">\(\sigma_g^2\)</span> und <span class="math inline">\(\sigma_e^2\)</span> von <span class="math inline">\(1\)</span> angenommen.</p>
<p>Aufgrund der letzten Zeile der GBLUP-Mischmodellgleichungen ist ersichtlich, dass die genomischen Zuchtwerte <span class="math inline">\(\hat{g}_2\)</span> der Tiere ohne phänotypische Beobachtungen aufgrund der Schätzungen <span class="math inline">\(\hat{g}_1\)</span> der genomischen Zuchtwerte der Tiere mit Beobachtungen vorhergesagt werden können.</p>
<span class="math display">\[\begin{equation}
\hat{g}_2 = -\left( G^{22}\right)^{-1}G^{21}\hat{g}_1
\label{eq:GenomicBvAnimalNoPhen}
\end{equation}\]</span>
<p>Die Beziehung in () wird auch als genomische Regression der Zuchtwerte der Tiere ohne Beobachtung auf die genomischen Zuchtwerte der Tiere mit Beobachtung bezeichnet.</p>

</div>
</div>
<h3>References</h3>
<div id="refs" class="references">
<div id="ref-Hofer1990">
<p>Hofer, A. 1990. “Schätzung von Zuchtwerten Feldgeprüfter Schweine Mit Einem Mehrmerkmals-Tiermodell.” PhD thesis, ETH Zürich.</p>
</div>
<div id="ref-vonRohr2016">
<p>von Rohr, P. 2016. “Züchtungslehre.” <a href="https://charlotte-ngs.github.io/LBGHS2016" class="uri">https://charlotte-ngs.github.io/LBGHS2016</a>.</p>
</div>
<div id="ref-MHG2001">
<p>Meuwissen, Theo HE, Ben J Hayes, and Mike E Goddard. 2001. “Prediction of Total Genetic Value Using Genome-Wide Dense Marker Maps.” <em>Genetics</em>, no. 157: 1819–29.</p>
</div>
<div id="ref-HFD2007">
<p>Habier, D., RL Fernando, and JCM Dekkers. 2007. “The Impact of Genetic Relationship Information on Genome-Assisted Breeding Values.” <em>Genetics</em>, no. 177: 2389–97.</p>
</div>
<div id="ref-MLA2009">
<p>Misztal, I, A Legarra, and I Aguilar. 2009. “Computing Procedures for Genetic Evaluation Including Phenotypic, Full Pedigree, and Genomic Information.” <em>J Dairy Sci</em>, no. 92: 4648–55.</p>
</div>
<div id="ref-VanRaden2008">
<p>VanRaden, PM. 2008. “Efficient Methods to Compute Genomic Predictions.” <em>J Dairy Sci</em>, no. 91: 4414–23.</p>
</div>
<div id="ref-GDHMF2009">
<p>Gianola, Daniel, Gustavo de los Campos, William G. Hill, Eduardo Manfredi, and Rohan Fernando. 2009. “Additive Genetic Variability and the Bayesian Alphabet.” <em>Genetics</em>, no. 183: 347–63.</p>
</div>
<div id="ref-CV2013">
<p>Clark, Samuel A., and Julius van der Werf. 2013. “Genomic Best Linear Unbiased Prediction (GBLUP) for the Estimation of Genomic Breeding Values.” In <em>Genome-Wide Association Studies and Genomic Prediction, Methods in Molecular Biology, Vol 1019</em>, edited by Cedric Gondro, Julius van der Werf, and Ben Hayes. Springer. doi:<a href="https://doi.org/10.1007/978-1-62703-447-0_13">10.1007/978-1-62703-447-0_13</a>.</p>
</div>
</div>
            </section>

          </div>
        </div>
      </div>
<a href="linreg.html" class="navigation navigation-prev " aria-label="Previous page"><i class="fa fa-angle-left"></i></a>
<a href="chpt-lasso.html" class="navigation navigation-next " aria-label="Next page"><i class="fa fa-angle-right"></i></a>
    </div>
  </div>
<script src="libs/gitbook-2.6.7/js/app.min.js"></script>
<script src="libs/gitbook-2.6.7/js/lunr.js"></script>
<script src="libs/gitbook-2.6.7/js/plugin-search.js"></script>
<script src="libs/gitbook-2.6.7/js/plugin-sharing.js"></script>
<script src="libs/gitbook-2.6.7/js/plugin-fontsettings.js"></script>
<script src="libs/gitbook-2.6.7/js/plugin-bookdown.js"></script>
<script src="libs/gitbook-2.6.7/js/jquery.highlight.js"></script>
<script>
require(["gitbook"], function(gitbook) {
gitbook.start({
"sharing": {
"github": false,
"facebook": true,
"twitter": true,
"google": false,
"weibo": false,
"instapper": false,
"vk": false,
"all": ["facebook", "google", "twitter", "weibo", "instapaper"]
},
"fontsettings": {
"theme": "white",
"family": "sans",
"size": 2
},
"edit": {
"link": "https://github.com/rstudio/bookdown-demo/edit/master/03-gblup.Rmd",
"text": "Edit"
},
"download": ["bookdown-asmas.pdf", "bookdown-asmas.epub"],
"toc": {
"collapse": "subsection"
}
});
});
</script>

<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
  (function () {
    var script = document.createElement("script");
    script.type = "text/javascript";
    script.src  = "https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML";
    if (location.protocol !== "file:" && /^https?:/.test(script.src))
      script.src  = script.src.replace(/^https?:/, '');
    document.getElementsByTagName("head")[0].appendChild(script);
  })();
</script>
</body>

</html>
